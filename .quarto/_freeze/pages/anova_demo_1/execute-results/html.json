{
  "hash": "b6aad97a25d07b94afd82a1477bd0e46",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Anova Demo\"\nauthor: \"Boris Mayer\"\nformat: \n  html:\n    resources:\n      - ../data/therapie.csv         # Include just the CSV\nengine: knitr\nfilters:\n  - webr\n# webr:\n#   packages:\n#     - tidyverse\nlicense: CC BY\ncitation: true\n---\n\n\n\n\n```{webr-r}\n#| context: setup\n\n# download all libraries\nlibrary(tidyverse)\nlibrary(afex)\nlibrary(emmeans)\nlibrary(car) # für Levene-Test\n# load data in workspace\ndownload.file(\"https://kogpsy.github.io/anova-demo/data/therapie.csv\", \n              \"therapie.csv\")\n```\n\n\n\n## Packages laden\n\n```{webr-r}\nlibrary(tidyverse)\nlibrary(afex)\nlibrary(emmeans)\nlibrary(car) # für Levene-Test\n```\n\n\n## A) Daten\n\n\n### 1) Daten einlesen und konvertieren \n\nLesen Sie den Datensatz `therapie` ein und konvertieren Sie die Variablen `id` und `bedingung` zu Faktoren:\n\n```{webr-r}\ntherapie <- read_csv(\"therapie.csv\") # einlesen\n\ntherapie <- therapie |> \n    mutate(id = as.factor(id),\n           bedingung = as.factor(bedingung))\n\ntherapie # Datensatz anschauen\n```\n\n\n\n### 2) Datensatz transformieren\n\nFühren Sie eine wide-to-long Transformation durch und bilden Sie damit einen Dataframe `therapie_long` mit einem messwiederholten Faktor `messzeitpunkt` und der (Outcome-)Variablen `wohlbefinden`. \n\nDefinieren Sie die Variable `messzeitpunkt` als Faktor mit den Faktorstufen \"beginn\", \"mitte\" und \"ende\" (in dieser Reihenfolge).\n\n\n```{webr-r}\ntherapie_long <- therapie |>\n    pivot_longer(cols = beginn:ende, \n                 names_to = \"messzeitpunkt\", \n                 values_to = \"wohlbefinden\")\n\ntherapie_long # anschauen\n\ntherapie_long <-  therapie_long |>  \n    mutate(messzeitpunkt = factor(messzeitpunkt, \n                                  levels = c(\"beginn\", \"mitte\", \"ende\")))\n\nlevels(therapie_long$messzeitpunkt) # Faktorstufenreihenfolge bestätigen\n```\n\n\n\n\n### 3) Mittelwerte berechnen\n\nBerechnen Sie mittels `group_by()` und `summarize()` die Mittelwerte von `wohlbefinden` getrennt nach `bedingung` und `messzeitpunkt` und speichern Sie diese in einem Dataframe `therapie_means` ab.\n\n```{webr-r}\ntherapie_means <- therapie_long |> \n  group_by(bedingung, messzeitpunkt) |> \n  summarize(wohlbefinden = mean(wohlbefinden))\n\ntherapie_means # Mittelwerte anschauen\n```\n\nWir können hier schon sehen, dass das Wohlbefinden - rein deskriptiv - in der Kontrollgruppe eher abnimmt und in der Therapiegruppe eher zunimmt. \n\n\n\n## B) Plotten mit `{ggplot2}`\n\n### 1) Plotten der Mittelwerte\n\nPlotten Sie die oben berechneten Mittelwerte mittels eines Liniendiagramms  mit zusätzlichen Punkten mit den drei Messzeitpunkten auf der X-Achse, den  Wohlbefindens-Werten auf der Y-Achse und mit Bedingung als (farbliche) Gruppierungsvariable.\n\nBeachten Sie, dass `geom_line()` ein zusätzliches `group`-Argument in `aes()` benötigt, um zu wissen, welche Punkte mit Linien verbunden werden sollen. Das allgemeine  `color = bedingung` der `ggplot()` Funktion genügt hier nicht (wird aber trotzdem benötigt, um Linien und Punkte mit nach Geschlecht unterschiedlichen Farben zu erhalten).\n    \n    \n```{webr-r}\np <- therapie_means |> \n    ggplot(aes(x = messzeitpunkt, y = wohlbefinden, color = bedingung))\n\np +\n  geom_line(aes(group = bedingung)) +\n  geom_point(size = 3) +\n  scale_color_manual(values = c(\"#000000\", \"#E69F00\")) \n```\n\n\nHier wird automatisch nur derjenige Auschnitt der `wohlbefindens`-Skala dargestellt, in dem sich die zu plottenden Mittelwerte befinden (diese liegen zwischen 3.33 und 4.23, s.o.). Dadurch wirkt es hier so, als gäbe es extrem grosse Mittelwertsunterschiede. Relativ zur Gesamtskala (1 bis 6) sind diese Unterschiede aber nicht ganz so bedeutsam wie es hier den Anschein erweckt.\n\n\n### 2) Plot verfeinern\n\nDaher plotten wir noch einmal und geben jetzt mit Hilfe von `scale_y_continuous()` an, dass die Y-Achse von `1` bis `6` gehen soll. Ausserdem soll der Plot noch (weiter) verschönert werden: er soll einen weissen Hintergrund bekommen sowie einen Titel und bessere korrektere Achsen- und Legendenbeschriftungen.\n\nAuch die Beschriftung der X-Achse lässt noch zu Wünschen übrig. Dafür benutzen wir `scale_x_discrete()` und geben im Argument `labels` einen character vector mit den richtigen (gross geschriebenen) Zeitpunkten an.\n\nDas Hauptargument von `scale_y_continuous()` ist `limits = c(wert_beginn, wert_ende)`, ausserdem kann mit `breaks` festgelegt werden, welche Werte-Abstände (\"Ticks\") auf der Achse dargestellt werden (Probieren Sie es zuerst ohne das `breaks`-Argument). \n\n```{webr-r}\np +\n  geom_line(aes(group = bedingung)) +\n  geom_point(size = 3) +\n  scale_color_manual(values = c(\"#000000\", \"#E69F00\")) +\n  scale_y_continuous(limits = c(1, 6), breaks = 1:6) +\n  scale_x_discrete(labels = c(\"Beginn\", \"Mitte\", \"Ende\")) +\n  theme_classic(base_size = 12) +\n  ggtitle(\"Wohlbefinden im Therapieverlauf\") +\n  xlab(\"Messzeitpunkt\") +\n  ylab(\"Wohlbefinden\") +\n  labs(color = \"Bedingung\")\n```\n\n\n## C) Zweifaktorielle ANOVA mit Messwiederholung mit afex und emmeans\n\n### 1) Mixed-Design-ANOVA\n\nFühren Sie die Mixed-Design-ANOVA mit `aov_4()` durch\n\n```{webr-r}\nanovaMIXED <- aov_4(wohlbefinden ~ bedingung + (messzeitpunkt | id), \n                    data = therapie_long)\n\nanovaMIXED_obs <- aov_4(wohlbefinden ~ bedingung + (messzeitpunkt | id), observed = c(\"bedingung\", \"messzeitpunkt\"),\n                   data = therapie_long)\n\nanovaMIXED_eff <- aov_4(wohlbefinden ~ bedingung + (messzeitpunkt | id), anova_table = list(es = c(\"ges\", \"pes\")),\n                    data = therapie_long)\n\nsummary(anovaMIXED)\n```\n\n\nMauchly-Test ist nicht signifikant, daher kann die Sphärizitätsannahme aufrecht-erhalten werden (keine Sphärizitätskorrektur erforderlich).\n\nFür die Effektstärke Generalized Eta-Square (ges) brauchen wir noch den ANOVA-Table:\n\n```{webr-r}\nanovaMIXED$anova_table\nanovaMIXED_obs$anova_table\nanovaMIXED_eff$anova_table\n```\n\nHier werden standardmässig (unabhängig vom Ergebnis des Mauchly-Tests) die \nGreenhouse-Geisser(GG)-korrigierten F-Tests berichtet.\n\n\nFür den Levene-Test benutzen wir `leveneTest()` aus car \n\n```{webr-r}\nleveneTest(wohlbefinden ~ bedingung, data = therapie_long, center = median)\n```\n\n\nnicht signifikant (alpha = 0.10), Voraussetzung der Homoskedastizität erfüllt\n\n\n### 2) afex-Plot der Mittelwerte\n\nFür den Plot verwenden wir die Funktion `afex_plot(object, x)`.\n\nAls erstes Argument der Funktion wird das Ergebnisobjekt der ANOVA benötigt. Für das Argument `x =` muss die Gruppierungsvariable/Faktor angegeben werden.\nFür das Argument `trace =` muss derjenige Faktor angegeben werden, für den separate Linien (mit Legende) ausgegeben werden sollen.\nFür Mixed-Designs sind weder die \"normalen\" noch die \"within\"-Fehlerbalken auf alle geschätzten Mittelwerte anwendbar. Deshalb wird empfohlen, bei Plots in Mixed-Designs auf Fehlerbalken/Konfidenzintervalle zu verzichten (`error = \"none\"`).\n\nIn einem Mixed-Design wie unserem ist es am sinnvollsten, den Faktor `messzeitpunkt` auf der X-Achse darzustellen und getrennte Linien für den Between-Faktor `bedingung` zu verwenden. Der Legendentitel kann mit dem Argument `legend.title` angepasst werden.\n\n`afex_plot()` erstellt ein ggplot-Objekt, welches wir weiter verändern können.\n\n```{webr-r}\np <- afex_plot(object = anovaMIXED,\n               x = \"messzeitpunkt\",\n               trace = \"bedingung\",\n               error = \"none\",\n               legend_title = \"Bedingung\")\n\np\n```\n\nweitere Optionen unter `help(afex_plot)`\n\nVerschönern Sie den Plot, indem Sie folgende Elemente hinzufügen:\n\n```{webr-r}\np +\n  theme_classic() +                               # Hintergrund weiss\n  ggtitle(\"Wohlbefinden im Therapieverlauf\") +    # Titel hinzufügen\n  xlab(\"Messzeitpunkt\") +                         # x-Achse beschriften\n  ylab(\"Wohlbefinden\")                            # y-Achse beschriften\n```\n\n\n### 3) Bedingte Haupteffekte\n\nBedingte Haupteffekte erhalten wir mit der Funktion `joint_tests(object, by)` aus dem `emmeans`-Package. Als erstes Argument wird das afex-Ergebnisobjekt der ANOVA benötigt. Für das Argument `by` muss derjenige Faktor angegeben werden, getrennt für dessen Stufen wir die bedingten Haupteffekte des jeweils anderen Faktors erhalten wollen.\n\nHier interessieren wir uns für die bedingten Haupteffekte des within-subject Faktors `messzeitpunkt` (getrennt für - by - die Stufen des between-subjects Faktors `bedingung`). \n\n```{webr-r}\njoint_tests(object = anovaMIXED, by = \"bedingung\")\n```\n\n\n### 4) Post-hoc-Einzelvergleiche für die bedingten Haupteffekte\n\nDie bedingten Haupteffekte zeigen nur, dass es insgesamt signifikante Unterschiede zwischen den Messzeitpunkten gibt. Jetzt wollen wir noch wissen, welche Messzeitpunkten sich jeweils signifikant unterscheiden (und welche nicht).\n\nUm diese Einzelvergleiche/Kontraste durchführen zu können, muss zuerst ein emmeans-Objekt (hier: result) erstellt werden, und zwar für die Interaktion `messzeitpunkt * bedingung`:\n\n```{webr-r}\nresult <- emmeans(object = anovaMIXED, specs = ~ messzeitpunkt * bedingung)\n```\n\nPost-hoc-Einzelvergleiche zwischen den Zeitpunkten (simple = \"messzeitpunkt\") getrennt für die beiden Bedingungen:\n\n```{webr-r}\npairs(result, simple = \"messzeitpunkt\", adjust = \"tukey\")\n```\n\nPolynomiale Trendtests in Bezug auf den Zeitverlauf (simple = \"messzeitpunkt\") getrennt für die beiden Bedingungen:\n\n```{webr-r}\nresult_poly <- emmeans(object = anovaMIXED, specs = ~ messzeitpunkt | bedingung)\ncontrast(object = result_poly, method = \"poly\", adjust = \"none\")\n```\n\n\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}